'use strict';
// 一回計算した値を、データとして持っておきたい。
const memo = new Map(); // Map を使うと、連想配列を便利に扱う事が出来る。
memo.set(0, 0);
memo.set(1, 1); // フィボナッチ数列のルール。
// set 関数と使うと、連想配列に値を登録する事が出来る。
// ここでは (〇, ◎) 第一引数に 〇 、第二引数に ◎ を設定している。

function fib(n) { // フィボナッチ数列の関数を作る。n 番目の数値を返すように設定。
  if (memo.has(n)) { // まずは memo に、求めたい n 番目の値が登録してあるかチェックし、
    return memo.get(n);// has を使うと、ある場合はトゥルーとなり、その値を返す。
    } // 無い場合はフォルスとなり、下の計算に移る。

    const value = fib(n - 1) + fib(n - 2); // n 番目 - 1 と n 番目 - 2 を足す。
    memo.set(n, value); // 計算で出た値を、もう一度 memo にセットし直す。
    return value; // セットし直してから、値を返す。
  }

const length = 1000; // 40 回繰り返す。
for (let i = 0; i <= length; i++) { // for 文 繰り返し。
  console.log(fib(i)); // ログに結果を表示。
}
// このメモを使ったアルゴリズムの改善をメモ化と言い、
// Ｏ記法で表すと、Ｏ(n) と記述する。
// この様なめちゃめちゃ早いオーダーを、線形(せんけい)オーダーと言う。